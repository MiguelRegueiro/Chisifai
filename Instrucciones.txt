Flip Sprint: GreenDelivery (3-4 semanas ¬∑ 10%)


Gemini_Generated_Image_iu9wqziu9wqziu9w.png



1. Contexto del Desaf√≠o üöõ


GreenDelivery es una startup de log√≠stica sostenible especializada en el transporte de productos org√°nicos y sensibles, como frutas, verduras y medicamentos, que requieren un control estricto de la cadena de fr√≠o. Para garantizar la m√°xima calidad y minimizar las p√©rdidas, la empresa necesita monitorear sus env√≠os en tiempo real.


Un incidente ‚Äîcomo una subida de temperatura por un fallo en la refrigeraci√≥n, un impacto brusco por una mala manipulaci√≥n o una desviaci√≥n de la ruta‚Äî puede arruinar una carga completa. Tu equipo ha sido contratado como consultor de Ingenier√≠a de Datos y Operaciones para construir el prototipo de un sistema de alerta temprana que solucione este problema.


Composici√≥n del Equipo: 3 a 4 estudiantes.


2. Misi√≥n del Equipo üéØ

Vuestra misi√≥n es dise√±ar, construir y desplegar un pipeline de datos funcional de extremo a extremo (Edge ‚Üí Cloud ‚Üí Decisi√≥n).


_- visual selection (3).png



Este sistema debe ser capaz de:


    Capturar telemetr√≠a desde dispositivos IoT (simulados) instalados en los env√≠os.
    Ingerir y almacenar estos datos de forma segura y eficiente en la nube.
    Procesar el flujo de datos para detectar incidentes en tiempo real aplicando reglas simples o un modelo b√°sico de Machine Learning.
    Generar alertas autom√°ticas e instant√°neas para el equipo de operaciones.
    Visualizar el estado de los env√≠os en un panel de control.


Todo el proceso debe desarrollarse bajo un enfoque de "Seguridad desde el Dise√±o", integrando buenas pr√°cticas desde el inicio.


3. Requisitos Clave del Prototipo üõ†Ô∏è

El pipeline debe incluir los siguientes componentes funcionales:


    Fuente de Datos (Edge): Un script o simulador que genere y env√≠e datos de telemetr√≠a (ej. ID_env√≠o, timestamp, temperatura, humedad, latitud, longitud, aceler√≥metro-ejeZ). Los datos deben enviarse a un endpoint en la nube de forma segura (usando TLS).
    Ingesta y Procesamiento (Cloud):
    Un servicio en la nube (ej. IoT Hub, API Gateway + Lambda, Pub/Sub) que reciba los datos del dispositivo.
    Un motor de procesamiento en tiempo real (ej. Stream Analytics, Kinesis, Cloud Functions) que analice cada evento entrante. La l√≥gica debe detectar anomal√≠as, por ejemplo:
    Regla de negocio: SI temperatura > 8.0 ¬∞C ENTONCES generar_alerta("Temperatura Excedida").
    Regla de ML sencilla: SI acelerometro_ejeZ > 3.0 G ENTONCES generar_alerta("Posible Impacto").
    Almacenamiento (Cloud): Una base de datos o sistema de almacenamiento (ej. DynamoDB, Firestore, BigQuery) donde se persistan todos los datos de telemetr√≠a recibidos, tanto los eventos normales como los incidentes.
    Acci√≥n y Visualizaci√≥n (Decisi√≥n):
    Un sistema de notificaci√≥n que se active cuando se detecta un incidente (ej. un email, un mensaje en un canal de Slack o Discord mediante un webhook).
    Un panel de control (dashboard) simple (ej. usando Looker Studio, Power BI, Grafana) que muestre la ubicaci√≥n y los valores de telemetr√≠a del √∫ltimo env√≠o en un mapa y/o gr√°ficos.


Paso 1: El Sensor IoT üå°Ô∏è (Fuente de Datos en el Borde)

Objetivo: Simular un dispositivo f√≠sico que est√° dentro de una caja de env√≠o, capturando y transmitiendo datos constantemente.


Descripci√≥n Detallada: Como no usar√©is un sensor real, deb√©is crear un script que act√∫e como un simulador. Este programa generar√° datos de telemetr√≠a realistas (un JSON con ID_env√≠o, timestamp, temperatura, etc.) a intervalos regulares (ej. cada 5 segundos). Luego, enviar√° estos datos a trav√©s de internet a un "endpoint" (una URL √∫nica) en la nube. La comunicaci√≥n debe ser segura, lo que se consigue f√°cilmente usando una URL que empiece por https (el protocolo se encarga del cifrado TLS).


Tecnolog√≠as y Alternativas:

    Lenguaje (Recomendado): Python es ideal por su simplicidad.
    Usa la librer√≠a requests para realizar las peticiones HTTP POST.
    Usa la librer√≠a faker o random para generar datos cre√≠bles.
    Formato de Datos: JSON es el est√°ndar de facto para este tipo de comunicaci√≥n.
    Alternativa m√°s avanzada: Usar el protocolo MQTT, que es m√°s eficiente para IoT, pero requiere un "broker" intermediario y es m√°s complejo de configurar que una simple petici√≥n HTTP. Para este proyecto, HTTP es m√°s que suficiente.


‚úÖ Resultado Esperado: Un script que, al ejecutarlo desde vuestro terminal, empieza a enviar paquetes de datos JSON a una URL de la nube cada pocos segundos.


Paso 2: La Puerta de Entrada a la Nube üö™ (Ingesta de Datos)

Objetivo: Crear un "buz√≥n" o punto de recepci√≥n en la nube que escuche y acepte los datos que env√≠a vuestro simulador.


Descripci√≥n Detallada: Este componente es la puerta de entrada p√∫blica y segura a vuestro sistema. Su √∫nica responsabilidad es recibir la petici√≥n HTTP del sensor, validar que es correcta (opcional, pero buena pr√°ctica) y pasarle el paquete de datos al siguiente componente para que sea procesado.


Tecnolog√≠as y Alternativas (Elegid una ruta):

    Ruta Serverless (Recomendada): Es la m√°s directa y flexible.
    AWS: API Gateway + Lambda.
    Google Cloud: Cloud Functions (con un trigger HTTP).
    Azure: Azure Functions (con un trigger HTTP).
    Ruta Espec√≠fica de IoT: M√°s robusta para gestionar flotas de miles de dispositivos, pero con una curva de aprendizaje mayor.
    AWS: IoT Core.
    Google Cloud: IoT Core.
    Azure: IoT Hub.


‚úÖ Resultado Esperado: Una URL funcional. Si la "llamas" desde tu script del Paso 1 (o incluso desde herramientas como Postman), los datos son recibidos en la nube y se activa el siguiente paso del pipeline.


Paso 3: El Cerebro del Sistema üß† (Procesamiento y Almacenamiento)

Objetivo: Analizar cada dato que llega, decidir si es una alerta, y guardar absolutamente todo para futuras consultas.


Descripci√≥n Detallada: La funci√≥n que creasteis en el Paso 2 (ej. vuestra Cloud Function o Lambda) contendr√° la l√≥gica de negocio. Por cada paquete de datos que recibe:

    Analiza: Revisa los valores. ¬øLa temperatura supera los 8¬∞C? ¬øEl aceler√≥metro indica un valor an√≥malo?
    Decide: Si se cumple una de las reglas, debe preparar una acci√≥n (la notificaci√≥n del Paso 4).
    Guarda: Independientemente de si es una alerta o no, SIEMPRE debe guardar el dato en una base de datos. Esto es crucial para tener un historial completo.

Tecnolog√≠as y Alternativas:

    L√≥gica de Procesamiento: La propia funci√≥n Serverless (Python, Node.js, etc.) es suficiente para este proyecto. Para sistemas a gran escala, se usan motores de streaming como Apache Flink, AWS Kinesis Analytics o Google Cloud Dataflow.


    Base de Datos (Recomendado: NoSQL): Son perfectas para este caso de uso por su flexibilidad y velocidad de escritura.
    AWS: DynamoDB.
    Google Cloud: Firestore o Bigtable.
    Azure: Cosmos DB.


    Alternativa (Data Warehouse): Google BigQuery es una excelente opci√≥n si se piensa en anal√≠tica a gran escala, ya que permite hacer consultas SQL muy potentes sobre vol√∫menes masivos de datos.


‚úÖ Resultado Esperado: Cada vez que el sensor env√≠a datos, una nueva entrada (fila/documento) aparece en vuestra base de datos en la nube.


Paso 4: La Alarma y el Panel de Control üìä (Acci√≥n y Visualizaci√≥n)

Objetivo: Notificar a un humano cuando algo va mal y mostrar el estado de todos los env√≠os de forma visual e intuitiva.


Descripci√≥n Detallada: Este es el paso final donde el valor de los datos se hace tangible.

    Acci√≥n (Notificaci√≥n): Si en el Paso 3 se detect√≥ una anomal√≠a, la misma funci√≥n debe realizar una llamada a una API externa para enviar un mensaje. La forma m√°s sencilla es usar un webhook, que es una URL que aplicaciones como Slack o Discord te proporcionan para que puedas publicar mensajes en un canal de forma program√°tica.
    Visualizaci√≥n (Dashboard): Esta es una aplicaci√≥n separada que se conecta en modo lectura a la base de datos del Paso 3. Su funci√≥n es consultar los datos y presentarlos de forma gr√°fica (mapas, series temporales, indicadores, etc.).


Tecnolog√≠as y Alternativas:

    Notificaci√≥n:
    Webhooks de Slack o Discord (Recomendado): Extremadamente f√°cil de configurar.
    Email: Usando servicios como Amazon SES, SendGrid o Mailgun.
    Visualizaci√≥n: Herramientas de Business Intelligence (BI) que ofrecen capas gratuitas generosas.
    Google Looker Studio (Recomendado): Muy f√°cil de usar y se integra de forma nativa con las herramientas de Google Cloud.
    Microsoft Power BI: Un est√°ndar en la industria, muy potente.
    Grafana: La mejor opci√≥n para visualizar datos de series temporales (como la temperatura a lo largo del tiempo), aunque puede requerir un poco m√°s de configuraci√≥n.


‚úÖ Resultado Esperado:

    Un mensaje autom√°tico aparece en vuestro canal de Slack/Discord cuando el simulador env√≠a un dato an√≥malo.
    Una p√°gina web (vuestro dashboard) donde se puede ver un mapa con la √∫ltima ubicaci√≥n del env√≠o y un gr√°fico que muestra el hist√≥rico de su temperatura.



4. Criterios de √âxito y Demo Final üèÜ

El √©xito del sprint se medir√° con una demostraci√≥n en vivo al final de las dos semanas. El escenario de la demo deber√° ser el siguiente:


    Inicio del Env√≠o: El equipo inicia el script simulador de un nuevo env√≠o.
    Monitoreo en Vivo: Se muestra el panel de control, donde los datos del env√≠o (ubicaci√≥n, temperatura, etc.) se actualizan en tiempo real.
    Simulaci√≥n de Incidente: Durante la demo, se fuerza una condici√≥n an√≥mala en el simulador (ej. se incrementa la temperatura por encima del umbral permitido).
    Detecci√≥n y Alerta: El sistema detecta la anomal√≠a en segundos, registra el incidente y env√≠a una notificaci√≥n visible a la plataforma elegida (email, Slack, etc.). El panel de control refleja visualmente el estado de alerta.
    Registro Persistente: Se comprueba que tanto los datos normales como el evento de la anomal√≠a han quedado guardados correctamente en la base de datos.


Te he montado el proyecto completo (con c√≥digo, flujos, SQL, diagrama, dataset etiquetado, evaluaci√≥n, gu√≠a y plantillas) para que superes el sprint de principio a fin.


GreenDelivery_FlipSprint.zip


1) Introducci√≥n: El Problema de la "Caja Negra" en la Log√≠stica


GreenDelivery transporta alimentos refrigerados. Una caja fuera de rango (temperatura alta o golpe fuerte) arruina el pedido y la confianza del cliente. Hoy no tienen trazabilidad: saben que ‚Äúalgo pas√≥‚Äù, pero no cu√°ndo ni d√≥nde. Necesitan ver los eventos, detectar lo an√≥malo y responder a tiempo.



Gemini_Generated_Image_udwduvudwduvudwd.png




La promesa de GreenDelivery a sus clientes es simple y poderosa: entregar productos frescos, de origen sostenible y con la m√°xima calidad garantizada. Se especializan en alimentos refrigerados de alto valor, donde la integridad de la cadena de fr√≠o no es una opci√≥n, sino una obligaci√≥n.

Sin embargo, detr√°s de esta promesa se esconde un gran desaf√≠o operativo: una vez que un env√≠o sale del almac√©n, se convierte en una "caja negra".


El Escenario Actual:

Un cliente importante llama. Un pedido entero de productos l√°cteos org√°nicos ha llegado "cortado". En otro caso, un restaurante de lujo rechaza una entrega de aguacates porque est√°n golpeados y magullados. El equipo de operaciones de GreenDelivery sabe que algo sali√≥ mal, pero se enfrenta a un muro de preguntas sin respuesta:

    ¬øCu√°ndo ocurri√≥ el incidente? ¬øFue un pico de temperatura de 15 minutos en un atasco bajo el sol, o un fallo del sistema de refrigeraci√≥n que dur√≥ horas?
    ¬øD√≥nde ocurri√≥? ¬øFue un manejo brusco durante la carga en el almac√©n, un bache severo en una carretera secundaria o un error del repartidor en la √∫ltima milla?
    ¬øPor qu√© ocurri√≥? ¬øSe debi√≥ a un fallo t√©cnico, un error humano o un factor externo inevitable?

Hoy, la respuesta es pura especulaci√≥n. No tienen trazabilidad. Solo pueden reaccionar cuando ya es demasiado tarde: cuando el producto est√° arruinado, el cliente est√° insatisfecho y la confianza en la marca se ha da√±ado.


El Coste de la Ignorancia:

Este desconocimiento tiene un coste alt√≠simo que va m√°s all√° del valor del producto perdido. Implica:

    P√©rdidas econ√≥micas directas por devoluciones y reembolsos.
    Da√±o reputacional que erosiona la imagen de calidad y fiabilidad de la marca.
    Ineficiencia operativa, al no poder identificar las causas ra√≠z para mejorar los procesos.
    P√©rdida de clientes valiosos que buscan proveedores m√°s fiables.


La Necesidad Estrat√©gica:

Para sobrevivir y crecer, GreenDelivery necesita transformar su operaci√≥n reactiva en un modelo proactivo y basado en datos. Necesitan un sistema que les d√© visibilidad en tiempo real dentro de cada env√≠o. El objetivo no es solo registrar fallos, sino detectar anomal√≠as en el instante en que ocurren para poder responder a tiempo, salvar una entrega o, como m√≠nimo, entender exactamente qu√©, cu√°ndo y d√≥nde fall√≥ el proceso para que no vuelva a suceder.


Gu√≠a Resumen.pdf


2) La historia (cap√≠tulos guiados)


Cap. 1 ‚Äî ‚ÄúDel sensor al primer dato‚Äù

"Si no vemos lo que ocurre en el cami√≥n, estamos ciegos. Necesitamos datos, no suposiciones." ‚Äî √ìscar, Jefe de Operaciones.


Misi√≥n de la Semana: üéØ Tu primera misi√≥n es construir el fundamento de todo el sistema: el camino que recorre un dato desde que se genera en un cami√≥n hasta que se almacena de forma segura. Pondr√°s en marcha un simulador, recibir√°s sus datos y te asegurar√°s de que ninguna informaci√≥n se pierda por el camino, incluso si hay fallos temporales.


Gemini_Generated_Image_ad3g7nad3g7nad3g.png



Paso 1: El Simulador del Tracker (Publisher MQTT)


Objetivo: Crear un script que imite a un dispositivo IoT real, generando y publicando datos de telemetr√≠a.

Descripci√≥n Detallada: Este script ser√° el coraz√≥n de tu fuente de datos. En un bucle infinito, cada 2 segundos, deber√°:

    Generar un objeto JSON con datos realistas para: temperatura, fuerza_g, id_paquete y timestamp.
    Publicar este JSON en un t√≥pico MQTT.

¬øPor qu√© MQTT? Es el protocolo est√°ndar en el mundo del IoT. Es extremadamente ligero y funciona con un modelo de publicaci√≥n/suscripci√≥n. Tu simulador "publica" mensajes en un canal (el "t√≥pico"), sin saber ni preocuparse de qui√©n los leer√°.

Tecnolog√≠as y Alternativas:

    Lenguaje (Recomendado): Python con la librer√≠a paho-mqtt. Es sencilla y muy robusta.
    T√≥pico MQTT: Define una ruta clara, por ejemplo: greendelivery/trackers/telemetry.
    Broker MQTT: Necesitar√°s un servidor MQTT para que act√∫e como intermediario. Puedes usar uno p√∫blico como test.mosquitto.org para empezar, o levantar uno localmente con Docker.

‚úÖ Resultado Esperado: Un script en Python que, al ejecutarlo, empieza a "gritar" mensajes JSON al t√≥pico MQTT especificado cada dos segundos. Puedes verificar que funciona usando un cliente MQTT gen√©rico (como MQTT Explorer) para "escuchar" ese t√≥pico.


Paso 2: La Estaci√≥n de Escucha y Procesamiento (Flujo Low-Code)


Objetivo: Capturar los mensajes del t√≥pico MQTT, validar su contenido y prepararlos para ser guardados.

Descripci√≥n Detallada: Aqu√≠ es donde entra la automatizaci√≥n visual. Usar√°s una herramienta de "low-code" para crear un flujo de trabajo que se dispare autom√°ticamente con cada mensaje MQTT. Este flujo debe:

    Suscribirse al t√≥pico greendelivery/trackers/telemetry.
    Recibir el mensaje JSON entrante.
    Validar que el JSON tiene la estructura correcta (contiene todos los campos esperados y los tipos de datos son correctos).
    Si es v√°lido, llamar al siguiente componente: la API de ingesta.

Tecnolog√≠as y Alternativas:

    Herramienta (Recomendada): Node-RED o n8n. Ambas son excelentes para prototipar y conectar servicios. Son como "LEGOs" para ingenieros: conectas nodos visualmente para construir un pipeline.
    Usar√°s un "Nodo MQTT In" para suscribirte.
    Un "Nodo de Funci√≥n" (escribiendo un poco de JavaScript) para la validaci√≥n del JSON.
    Un "Nodo HTTP Request" para llamar a la API del siguiente paso.

‚úÖ Resultado Esperado: Un flujo en Node-RED o n8n que muestra visualmente c√≥mo cada mensaje MQTT que llega es recibido y procesado, resultando en una llamada a tu API de ingesta.


Paso 3: La Persistencia Robusta (API y Base de Datos)


Objetivo: Guardar los datos validados en una base de datos relacional de forma segura y fiable.

Descripci√≥n Detallada: El "Starter Kit" del proyecto ya te proporciona dos piezas clave:

    Una Base de Datos PostgreSQL, el est√°ndar de oro para datos estructurados.
    Una API de Ingesta (ingest_api) construida con FastAPI.

¬øPor qu√© una API intermedia? Para desacoplar. Tu flujo de Node-RED no necesita saber c√≥mo hablar con Postgres. Solo necesita saber c√≥mo hacer una petici√≥n HTTP POST a /ingest. Esto hace que el sistema sea m√°s modular y seguro. Tu tarea es usar esta API, no construirla.

El Reto de la Fiabilidad: ¬øQu√© pasa si la API est√° ca√≠da o la base de datos est√° en mantenimiento cuando llega un dato? ¬°No se puede perder! Tu flujo de Node-RED debe implementar una l√≥gica de reintentos. Si la llamada HTTP a la API falla (ej. devuelve un error 503), el flujo debe esperar un momento (ej. 5 segundos) y volver a intentarlo.

Tecnolog√≠as y Alternativas:

    API: La API de FastAPI proporcionada. Expl√≥rala abriendo su documentaci√≥n interactiva en http://localhost:8000/docs.
    Base de Datos: El PostgreSQL incluido en el proyecto.
    L√≥gica de Reintentos: Investiga c√≥mo configurar reintentos en el "Nodo HTTP Request" de Node-RED/n8n o c√≥mo usar nodos de "catch" y "delay" para construir tu propia l√≥gica de reintentos.

‚úÖ Resultado Esperado: Datos de telemetr√≠a almacenados correctamente como filas en una tabla de PostgreSQL.


Prueba Superada Cuando... üèÜ

Puedes demostrar de forma concluyente que tu pipeline funciona de extremo a extremo y es resiliente:

    Ejecutas tu simulador y los mensajes fluyen por MQTT.
    Muestras tu flujo en Node-RED/n8n procesando los eventos en tiempo real.
    Haces una consulta SELECT a tu tabla en PostgreSQL y muestras una secuencia de eventos almacenados, cada uno con su timestamp correcto.
    Simulas un fallo (ej. detienes el contenedor de la API) y demuestras que, una vez restaurado el servicio, los eventos que llegaron durante la ca√≠da se procesan y se guardan correctamente, sin perderse.



Cap. 2 ‚Äî ‚ÄúArquitectura con prop√≥sito‚Äù

"Cualquiera puede hacer que algo funcione. Un ingeniero sabe por qu√© funciona y por qu√© se va a romper." ‚Äî Principio de Ingenier√≠a de Software.


Misi√≥n de la Semana: üéØ En el cap√≠tulo anterior, construisteis un pipeline funcional. Ahora, dar√©is un paso atr√°s para actuar como arquitectos de software. Vuestra misi√≥n es documentar y justificar el dise√±o del sistema que hab√©is creado. No se trata solo de "qu√©" hab√©is construido, sino de "por qu√©" lo hab√©is hecho de esa manera, explicando las ventajas y los compromisos (trade-offs) de cada decisi√≥n..).


Gemini_Generated_Image_87qr1j87qr1j87qr.png



Paso 1: El Mapa del Sistema (Diagrama de Arquitectura)

Objetivo: Crear una representaci√≥n visual, clara y simple de vuestro pipeline de datos.

Descripci√≥n Detallada: Un buen diagrama de arquitectura es como un mapa: permite a cualquiera entender el sistema de un solo vistazo. Deb√©is dibujar un diagrama de bloques que muestre los componentes principales y c√≥mo fluyen los datos entre ellos. No necesita ser excesivamente complejo; la claridad es m√°s importante que el detalle.

Componentes a Incluir: Deb√©is representar claramente cada una de estas "paradas" en el viaje del dato: Edge ‚Üí Broker MQTT ‚Üí Flujo de Ingesta ‚Üí Almacenamiento (Storage) ‚Üí Panel de Control (Dashboard)

Herramientas Recomendadas:

    Diagrams.net (antes Draw.io): Gratuita, potente y se integra con Google Drive/GitHub.
    Miro / Lucidchart: Excelentes para la colaboraci√≥n en equipo.
    Incluso una diapositiva bien estructurada en Google Slides o PowerPoint es suficiente.

‚úÖ Resultado Esperado: Una imagen (ej. un archivo PNG o un PDF) que contenga un diagrama de bloques limpio y legible, con flechas que indiquen la direcci√≥n del flujo de datos.


Paso 2: La Justificaci√≥n de Cada Bloque (An√°lisis de Decisiones)

Objetivo: Explicar el prop√≥sito de cada componente, por qu√© se eligi√≥ una tecnolog√≠a espec√≠fica y qu√© se gan√≥ o perdi√≥ con esa elecci√≥n.

Descripci√≥n Detallada: Para cada bloque de vuestro diagrama, deb√©is rellenar una "Ficha de Decisi√≥n Arquitect√≥nica". Esto os obliga a pensar cr√≠ticamente sobre vuestro propio trabajo.

Para cada uno de los 5 componentes (Edge, Broker, etc.), responded a estas preguntas:

    Prop√≥sito: ¬øCu√°l es la responsabilidad √∫nica de este componente? Describidlo en una sola frase. (Ej: "El Broker MQTT desacopla a los publicadores de los suscriptores de datos").
    Tecnolog√≠a Implementada: ¬øQu√© herramienta o servicio espec√≠fico hab√©is usado? (Ej: "Script de Python con Paho-MQTT", "Node-RED", "PostgreSQL en Docker").
    Justificaci√≥n Cloud: ¬øQu√© caracter√≠stica fundamental de la nube hace que esta elecci√≥n sea inteligente? No basta con nombrar la tecnolog√≠a; deb√©is conectar vuestra elecci√≥n con un principio de dise√±o cloud. Aqu√≠ ten√©is algunos ejemplos:

    Servicio Gestionado (Managed Service): ¬øElegisteis un servicio (ej. AWS IoT Core, Google Firestore) para no tener que gestionar servidores? Ventaja: Menos carga operativa.
    Elasticidad / Escalabilidad bajo demanda: ¬øEl componente puede crecer o decrecer autom√°ticamente seg√∫n la carga de trabajo? (Ej: una funci√≥n serverless). Ventaja: Pagas solo por lo que usas y soportas picos de tr√°fico.
    Desacoplamiento: ¬øEl componente permite que otras partes del sistema fallen sin derribar todo el conjunto? (Ej: el Broker MQTT). Ventaja: Mayor resiliencia y mantenibilidad.
    Seguridad por Defecto: ¬øEl servicio cloud os proporciona mecanismos de seguridad integrados (cifrado, gesti√≥n de identidades, etc.)? Ventaja: Reduce la superficie de ataque.

    Trade-off Clave: ¬øA qu√© renunciasteis al hacer esta elecci√≥n? Toda decisi√≥n de ingenier√≠a implica un compromiso. Sed honestos. Aqu√≠ ten√©is ejemplos de trade-offs:

    Servicio Gestionado: Menos control, posible "vendor lock-in" (dependencia del proveedor).
    Serverless (ej. AWS Lambda): "Arranques en fr√≠o" (cold starts), l√≠mites en el tiempo de ejecuci√≥n.
    Elegir NoSQL en vez de SQL: P√©rdida de transacciones ACID complejas a cambio de flexibilidad de esquema.
    Auto-hospedar en una VM: Mayor control y flexibilidad a cambio de mayor responsabilidad en mantenimiento, parches y escalado.

‚úÖ Resultado Esperado: Un documento de texto o una segunda diapositiva en una presentaci√≥n que contenga las cinco "Fichas de Decisi√≥n", una para cada componente del pipeline.


Prueba Superada Cuando... üèÜ

Entreg√°is un √∫nico documento (PDF o una mini-presentaci√≥n de 2-3 diapositivas) que un compa√±ero de otro equipo pueda leer y, sin haceros una sola pregunta, sea capaz de:

    Entender el flujo de datos mirando vuestro diagrama.
    Explicar con sus propias palabras para qu√© sirve cada pieza del sistema.
    Justificar por qu√© una funci√≥n serverless fue una buena idea para la ingesta (o por qu√© no lo fue) y cu√°l es su principal inconveniente.
    Argumentar por qu√© usar un broker MQTT es mejor que hacer que el sensor env√≠e los datos directamente a la base de datos.



Cap. 3 ‚Äî ‚ÄúDe dato a decisi√≥n‚Äù

"Los datos por s√≠ solos no valen nada. El valor est√° en las decisiones que te permiten tomar." ‚Äî Proverbio del An√°lisis de Datos.


Misi√≥n de la Semana: üéØ Ya ten√©is un flujo de datos fiable. Ahora es el momento de darle inteligencia. Vuestra misi√≥n es transformar ese flujo de telemetr√≠a en un sistema de detecci√≥n de incidentes √∫til para el negocio. Implementar√©is la l√≥gica que decide cu√°ndo levantar una bandera roja y, lo m√°s importante, medir√©is cient√≠ficamente qu√© tan buena es esa l√≥gica.


Gemini_Generated_Image_tfcbh4tfcbh4tfcb.png


Paso 1: La L√≥gica de Detecci√≥n (M√°s All√° de un Umbral Simple)

Objetivo: Implementar una regla de negocio que identifique incidentes reales, ignorando el "ruido" de eventos aislados.

Descripci√≥n Detallada: Un bache en la carretera puede generar un pico de fuerza_g de 3.0 durante un segundo. Esto no es un incidente. Pero si esa fuerza se mantiene alta durante 10 segundos, es muy probable que la caja se haya ca√≠do y est√© siendo arrastrada. Vuestra l√≥gica debe ser "stateful" (con estado), es decir, debe tener memoria para recordar lo que ha pasado recientemente.

Vuestra tarea es implementar la siguiente regla: Se genera una alerta si la temperatura > 8¬∞C O la fuerza_g > 2.5G de forma sostenida durante N eventos consecutivos para un mismo id_paquete.

    El Desaf√≠o: ¬øC√≥mo implementas el contador N? Tu procesador (Node-RED, la funci√≥n Lambda/Cloud) necesita almacenar el estado reciente de cada paquete activo. Puedes usar una variable de contexto, un peque√±o objeto en memoria o una cach√© externa como Redis para lograrlo.
    Decisi√≥n Clave: Vosotros deb√©is elegir un valor para N (ej. 3, 5, 10 eventos) y justificar por qu√© ese valor tiene sentido para el negocio.

‚úÖ Resultado Esperado: C√≥digo en vuestro procesador que implementa esta l√≥gica con memoria, capaz de distinguir entre un pico aislado y una condici√≥n an√≥mala sostenida.


Paso 2: La Ciencia de la Medici√≥n (Eligiendo la M√©trica Correcta)

Objetivo: Definir c√≥mo medir el √©xito de vuestra regla de detecci√≥n antes de escribir la versi√≥n final.

Descripci√≥n Detallada: ¬øC√≥mo sabes si tu regla es buena, mediocre o mala? Usando datos. En la carpeta analytics/ del proyecto, encontrar√©is el fichero labels.csv, que contiene datos de telemetr√≠a hist√≥ricos donde cada evento ya ha sido etiquetado manualmente como parte de un incidente real o no. Este es vuestro "examen".

Antes de nada, deb√©is decidir qu√© m√©trica usar√©is para evaluaros. No todas valen para lo mismo. Hacedle esta pregunta al "jefe de operaciones" (a vuestro equipo): "¬øQu√© es peor para GreenDelivery?"

    Opci√≥n A: Un Falso Positivo. Enviar una alerta cuando no pasa nada. Un operario pierde 5 minutos revisando un env√≠o que est√° bien.
    Opci√≥n B: Un Falso Negativo. No enviar una alerta cuando un env√≠o se est√° estropeando. La empresa pierde miles de euros y la confianza de un cliente.

Vuestra respuesta a esta pregunta determinar√° la m√©trica a optimizar:

    Precisi√≥n (Precision): Mide la calidad de tus alertas. Si la Precisi√≥n es alta, significa que cuando tu sistema dispara una alerta, casi siempre acierta. El√≠gela si quieres minimizar los Falsos Positivos. Precisi√≥n = Verdaderos Positivos / (Verdaderos Positivos + Falsos Positivos)
    Exhaustividad (Recall / Sensibilidad): Mide la cantidad de incidentes que eres capaz de "atrapar". Si el Recall es alto, significa que casi ning√∫n incidente real se te escapa. El√≠gela si quieres minimizar los Falsos Negativos. Recall = Verdaderos Positivos / (Verdaderos Positivos + Falsos Negativos)
    Puntuaci√≥n F1 (F1-Score): Es la media arm√≥nica entre las dos. Es una buena m√©trica general si buscas un equilibrio entre no molestar a los operarios y no perder incidentes.

‚úÖ Resultado Esperado: Una decisi√≥n de equipo clara y justificada sobre qu√© m√©trica (Precisi√≥n, Recall o F1) es la m√°s importante para el negocio de GreenDelivery.


Paso 3: La Prueba de Fuego (Implementaci√≥n y Evaluaci√≥n)

Objetivo: Probar vuestra l√≥gica contra el set de datos etiquetado y obtener un resultado cuantificable.

Descripci√≥n Detallada: Ahora, juntad los dos pasos anteriores. Deb√©is crear un script de evaluaci√≥n (por ejemplo, en Python con la librer√≠a pandas y scikit-learn) que:

    Lea el fichero analytics/labels.csv.
    Simule el flujo de eventos, aplicando vuestra l√≥gica de "N eventos sostenidos" a los datos.
    Compare las alertas que vuestro script genera con las etiquetas reales del fichero.
    Calcule la Precisi√≥n, el Recall y el F1-Score de vuestra implementaci√≥n y presente una matriz de confusi√≥n.

‚úÖ Resultado Esperado: Un script que produce las m√©tricas de rendimiento de vuestra regla.


Prueba Superada Cuando... üèÜ

Entreg√°is un informe de resultados (puede ser un README.md detallado o una presentaci√≥n de 2-3 diapositivas) que incluya:

    La L√≥gica Implementada: Explicad vuestra elecci√≥n del valor N y c√≥mo gestionasteis el estado.
    La M√©trica de Negocio: Justificad por qu√© elegisteis optimizar para Precisi√≥n, Recall o F1, bas√°ndoos en el impacto para GreenDelivery.
    Los Resultados Cuantificados: Mostrad la matriz de confusi√≥n y el valor de vuestra m√©trica principal.
    Conclusi√≥n:

    Si la m√©trica es ‚â• 0.7, ¬°enhorabuena! Explicad brevemente por qu√© vuestra l√≥gica funciona bien.
    Si la m√©trica es < 0.7, presentad una justificaci√≥n s√≥lida de los trade-offs. Este escenario es igual de v√°lido si el an√°lisis es bueno. Por ejemplo: "Nuestro F1-Score es 0.65. Hemos logrado un Recall alt√≠simo de 0.95 a costa de una Precisi√≥n baja, porque hemos priorizado no dejar pasar ning√∫n incidente real, asumiendo el coste de generar m√°s falsas alarmas. El siguiente paso ser√≠a..."


Cap. 4 ‚Äî ‚ÄúKPIs que importan‚Äù

"Medir lo que importa es f√°cil. Lo dif√≠cil es saber qu√© importa medir." ‚Äî Adaptado de John Doerr, "Mide lo que Importa".


Misi√≥n de la Semana: üéØ Hab√©is construido un sistema que detecta incidentes y hab√©is medido su rendimiento t√©cnico con m√©tricas como F1-Score. Ahora, el desaf√≠o final es comunicar el valor de vuestro trabajo a negocio. Vuestra misi√≥n es crear un panel de control (dashboard) que muestre los Indicadores Clave de Rendimiento (KPIs) que le importan a √ìscar, el jefe de operaciones. No se trata de mostrar datos, sino de contar una historia y proponer mejoras basadas en ellos.
Gemini_Generated_Image_vtibsxvtibsxvtib.png


Paso 1: Definiendo los Indicadores de Negocio

Objetivo: Traducir los eventos t√©cnicos en m√©tricas que respondan a las preguntas clave del negocio: ¬øEstamos cumpliendo nuestra promesa de calidad? ¬øSomos eficientes? ¬øPodemos confiar en nuestro sistema de alertas?

Descripci√≥n Detallada: Un buen KPI es simple de entender, accionable y est√° directamente ligado a un objetivo de la empresa. Deb√©is calcular y visualizar los siguientes tres KPIs:

    KPI 1: % de Env√≠os en SLA (Tasa de √âxito)

    Pregunta de Negocio: ¬øQu√© porcentaje de nuestros env√≠os llegan a su destino sin problemas de calidad?
    C√°lculo: (N√∫mero de env√≠os √∫nicos sin alertas cr√≠ticas / N√∫mero total de env√≠os √∫nicos en el per√≠odo) * 100
    Por qu√© importa: Es el indicador de m√°s alto nivel sobre la calidad del servicio. Un 99% en este KPI es la prueba de que GreenDelivery cumple su promesa.

    KPI 2: Tiempo Medio de Detecci√≥n (MTTD - Velocidad de Reacci√≥n)

    Pregunta de Negocio: Cuando ocurre un problema, ¬øcu√°nto tardamos en darnos cuenta?
    C√°lculo: Para cada incidente, calcula la diferencia de tiempo entre el timestamp del primer evento an√≥malo y el timestamp de la alerta generada. El KPI es la media de estas diferencias.
    Por qu√© importa: Cada segundo cuenta. Un MTTD bajo (ej. < 30 segundos) significa que el equipo de operaciones tiene tiempo para llamar al conductor y tomar acciones correctivas. Un MTTD alto (ej. > 5 minutos) significa que el sistema solo sirve para hacer autopsias de env√≠os fallidos.

    KPI 3: % de Falsos Positivos (√çndice de Confianza)

    Pregunta de Negocio: ¬øCu√°ntas de nuestras alertas son "falsas alarmas" que hacen perder el tiempo a nuestro personal?
    C√°lculo: (N√∫mero de alertas marcadas como 'falso positivo' / N√∫mero total de alertas generadas) * 100
    Por qu√© importa: Este KPI mide la eficiencia y la fiabilidad del sistema. Si este porcentaje es alto, los operarios desarrollar√°n "fatiga de alertas" y empezar√°n a ignorarlas, haciendo que todo el sistema sea in√∫til. Para poder calcularlo, necesitar√©is simular una forma en la que un operario pueda "marcar" una alerta como falsa (puede ser una simple tabla extra en la base de datos).


Paso 2: La Construcci√≥n del Panel de Control

Objetivo: Crear una interfaz visual simple y clara donde estos KPIs se puedan consultar de un vistazo.

Descripci√≥n Detallada: El dashboard es la cara visible de todo vuestro proyecto para el resto de la empresa. Debe ser intuitivo y estar enfocado en presentar estos tres KPIs sin distracciones. El principal desaf√≠o t√©cnico aqu√≠ ser√° escribir las consultas SQL que agreguen los datos brutos de vuestra base de datos de telemetr√≠a para calcular cada KPI.

Tecnolog√≠as y Alternativas:

    Herramientas de BI: Usad la que prefir√°is (Google Looker Studio, Power BI, Grafana).
    Fuente de Datos: Conectad la herramienta directamente a vuestra base de datos PostgreSQL.
    Consultas SQL: Aqu√≠ es donde aplicar√©is vuestras habilidades de bases de datos. Necesitar√©is usar agregaciones (COUNT, AVG), uniones (JOIN si simul√°is la tabla de falsos positivos) y posiblemente subconsultas o CASE para segmentar los datos correctamente.

‚úÖ Resultado Esperado: Una URL a un dashboard funcional que muestre los tres KPIs claramente, actualiz√°ndose a medida que llegan nuevos datos (o al menos, actualiz√°ndose bajo demanda).


Prueba Superada Cuando... üèÜ

Realiz√°is una demostraci√≥n final donde no solo mostr√°is el panel, sino que demostr√°is vuestra capacidad para usarlo como una herramienta estrat√©gica:

    Present√°is el dashboard en vivo, mostrando los tres KPIs calculados a partir de los datos generados.
    Eleg√≠s un KPI (el que consider√©is m√°s relevante o mejorable) y explic√°is una propuesta de mejora concreta, accionable y basada en datos.

Ejemplo de explicaci√≥n:

"Nuestro dashboard muestra que el KPI de falsos positivos est√° en un 18%, lo cual es demasiado alto. Analizando los datos, hemos visto que la mayor√≠a de estas falsas alarmas provienen de picos de fuerza_g en env√≠os que pasan por la zona centro, que est√° llena de badenes. Nuestra propuesta concreta para mejorar esta m√©trica es modificar nuestra regla de detecci√≥n: en lugar de un umbral global, aplicaremos un umbral de 3.0G para los paquetes cuya ruta pase por el centro y mantendremos el de 2.5G para el resto. Estimamos que este cambio podr√≠a reducir el KPI de falsos positivos a menos del 10% sin comprometer la detecci√≥n de impactos reales en otras zonas."


Cap. 5 ‚Äî ‚ÄúSeguridad por dise√±o + boss fight‚Äù


"La seguridad no es un producto, es un proceso. Y la resiliencia no es recuperarse del desastre, es no fallar en primer lugar." ‚Äî Principio de Ingenier√≠a de Fiabilidad de Sistemas (SRE).


Misi√≥n de la Semana: üéØ Hasta ahora, hab√©is construido un sistema que funciona. Esta semana, os asegurar√©is de que sea un sistema en el que se pueda confiar. Vuestra misi√≥n es blindar vuestro pipeline aplicando los principios fundamentales de la seguridad de la informaci√≥n (la tr√≠ada CIA) y prepararlo para sobrevivir a un fallo catastr√≥fico en la prueba final: la "Boss Fight".


Gemini_Generated_Image_qpvnsuqpvnsuqpvn.png


Paso 1: Confidencialidad (C) - Protegiendo los Secretos

Objetivo: Eliminar cualquier informaci√≥n sensible del c√≥digo fuente.

Descripci√≥n Detallada: Un repositorio de Git es p√∫blico o semi-p√∫blico. Dejar una contrase√±a, una clave de API o la direcci√≥n de una base de datos en el c√≥digo es el equivalente a dejar las llaves de casa pegadas en la puerta. Es el error de seguridad m√°s com√∫n y m√°s f√°cil de evitar. Vuestra tarea es aseguraros de que ning√∫n secreto est√© "hardcodeado".

Acciones Concretas:

    Cread un fichero .env en la ra√≠z de vuestros servicios.
    Moved todas las variables de configuraci√≥n sensibles (credenciales de la BD, tokens de API, etc.) a este fichero.
    A√±adid .env a vuestro fichero .gitignore para aseguraros de que nunca se suba al repositorio.
    Vuestro c√≥digo debe leer estas variables desde el entorno, no directamente del fichero. Librer√≠as como python-dotenv en Python o dotenv en Node.js facilitan este proceso.

‚úÖ Resultado Esperado: Pod√©is borrar vuestro repositorio local, clonarlo de nuevo y, tras crear un fichero .env a mano, todo el sistema vuelve a funcionar. No queda ni un solo secreto en el c√≥digo.


Paso 2: Integridad (I) - No Confiar en Nadie

Objetivo: Garantizar que los datos que entran en vuestro sistema son v√°lidos y no maliciosos.

Descripci√≥n Detallada: Vuestra API de ingesta es una puerta abierta a internet. Deb√©is asumir que alguien, intencionadamente o por error, intentar√° enviar datos mal formados. Sin una validaci√≥n robusta, un simple JSON incorrecto podr√≠a corromper vuestra base de datos o incluso tumbar vuestro servicio.

Acciones Concretas:

    Validaci√≥n de Tipos: Aseguraos de que la temperatura es un n√∫mero (float o integer), el timestamp es una fecha v√°lida y el id_paquete es un string. FastAPI (usando Pydantic) hace esto casi autom√°ticamente, pero deb√©is ser expl√≠citos en vuestros modelos.
    Validaci√≥n de Rango: A√±adid l√≥gica que verifique que los valores est√°n dentro de l√≠mites razonables. Una temperatura de 5000¬∞C o una fuerza_g de -100 no tienen sentido f√≠sico y deben ser rechazadas.

‚úÖ Resultado Esperado: Vuestra API rechaza peticiones con datos incorrectos (tipos o rangos inv√°lidos) con un c√≥digo de error claro (ej. 422 Unprocessable Entity), protegiendo el resto del sistema.


Paso 3: Disponibilidad (A) - Dise√±ando para Sobrevivir

Objetivo: Construir un sistema que no pierda datos ante fallos temporales.

Descripci√≥n Detallada: En la nube, los fallos son la norma, no la excepci√≥n. Una red puede tener microcortes, una base de datos puede reiniciarse para aplicar un parche. Vuestro sistema debe ser lo suficientemente inteligente como para manejar estos fallos transitorios sin perder ni un solo evento.

Acciones Concretas:

    Implementad una Estrategia de Reintentos con Backoff Exponencial: Si vuestro flujo de ingesta (Node-RED/n8n) no puede conectar con la API, no debe rendirse. Debe esperar 1 segundo y reintentar. Si vuelve a fallar, espera 2s, luego 4s, y as√≠ sucesivamente. Esto evita saturar un servicio que est√° intentando recuperarse.
    (Opcional, pero recomendado) Usad una Cola de Mensajes (Queue): La soluci√≥n m√°s robusta es poner una cola (como RabbitMQ o un servicio cloud como AWS SQS) entre el flujo de ingesta y la API. El flujo publica el evento en la cola (operaci√≥n muy r√°pida y fiable) y un "worker" separado lee de la cola e intenta guardarlo en la BD. Si la BD est√° ca√≠da, el mensaje simplemente permanece en la cola, seguro, hasta que el worker pueda procesarlo.

‚úÖ Resultado Esperado: Pod√©is detener manualmente vuestra API o BD durante unos segundos, y los eventos que llegan durante ese tiempo no se pierden, sino que se procesan en cuanto el servicio se restaura.


La Batalla Final (Boss Fight) - Prueba de Resiliencia en Vivo

Escenario: Durante la presentaci√≥n en clase, en un momento aleatorio, el profesor "tirar√°" vuestra base de datos durante 60 segundos seguidos.

Vuestra Misi√≥n:

    Vuestro simulador seguir√° funcionando y publicando datos a MQTT como si nada.
    Vuestro sistema de ingesta debe resistir. Los datos entrantes no pueden ser descartados. Deben ser almacenados temporalmente (en la memoria del flujo de reintentos o, mucho mejor, en una cola persistente).
    Cuando el profesor restaure la base de datos, vuestro sistema debe recuperarse autom√°ticamente, procesar el "atasco" de datos acumulados y volver al estado normal sin intervenci√≥n manual.


Prueba Superada Cuando... üèÜ

Demostr√°is, sin lugar a dudas, que hab√©is vencido al caos:

    Observ√°is el fallo: Mostr√°is los logs o el estado de vuestro flujo, donde se ve claramente que las inserciones en la base de datos est√°n fallando y los reintentos est√°n activos (o los mensajes se est√°n acumulando en la cola).
    Verific√°is la recuperaci√≥n: Una vez la base de datos vuelve a estar online, mostr√°is c√≥mo el sistema procesa la carga acumulada y vuelve a la normalidad.
    Aport√°is la evidencia forense: Realiz√°is una consulta SELECT a la base de datos y demostr√°is que los timestamps de los eventos cubren el per√≠odo de 60 segundos de la ca√≠da. No hay huecos. No se ha perdido ni un solo dato.



3) Los Deberes (resumen operativo)


Entregas 

    diagrams/arquitectura_T2.png (con rasgos cloud anotados).
    flows/ (Node-RED y/o n8n export) con validaci√≥n y reintentos.
    db/ddl.sql (tablas telemetry, alerts).
    dashboards/metabase/ (export/capturas) + consultas.
    security/CIA_minithreats.md (amenazas y mitigaciones).
    doc/Informe_T2_EquipoX.pdf (‚â§4 p√°gs.) + v√≠deo (3‚Äì5 min).


Marco te√≥rico (qu√© debes dominar)


    Cloud Computing (NIST 5 rasgos; IaaS/PaaS/SaaS; h√≠brida/multicloud): elasticidad, pago por uso, regiones; riesgos: lock-in, coste, cumplimiento.
    Big Data (5V; batch vs stream; lago/almac√©n; Kafka/Spark/Flink ‚Äì idea general): del dato crudo a la decisi√≥n.
    IoT (capas: percepci√≥n ‚Üí red ‚Üí edge/cloud ‚Üí aplicaci√≥n; MQTT/HTTP; LPWAN/5G).
    IA/ML (supervisado vs no supervisado; ciclo b√°sico; m√©tricas) para una detecci√≥n simple.
    Ciberseguridad (CIA + extensiones; Zero-Trust; IAM; DevSecOps b√°sico): seguridad transversal, no un ‚Äúa√±adido‚Äù.

Estas secciones est√°n en tu Tema 2: Cloud, Big Data, IoT, IA/ML  y Ciberseguridad. L√©elas antes de cada sesi√≥n.


TEMA 2..docx



Flipped Classroom: qu√© saber antes de clase


Semana 1 ‚Äî Pre-clase (30‚Äì40 min)

    Lectura guiada: Cloud (¬ß3.a, modelos y 5 rasgos) + IoT (¬ß3.c, arquitectura) + Big Data 5V (¬ß3.b). Marca 3 ideas clave y 1 duda.
    Mini-quiz (3 √≠tems) en Blackboard:

    Diferencia evento vs muestra en IoT.
    ¬øQu√© rasgo del NIST respalda el auto-scaling?
    Elige dos riesgos de multicloud/migraci√≥n.

    V√≠deo corto (propio o recomendado por el profe): MQTT en 5‚Ä≤ (publisher/subscriber).


Semana 2 ‚Äî Pre-clase (30‚Äì40 min)

    Lectura guiada: IA/ML (¬ß4.a‚Äì4.b, supervisado; m√©tricas b√°sicas) + Ciberseguridad (¬ß5, CIA + IAM/Zero-Trust).
    Mini-quiz (3 √≠tems):

    ¬øCu√°ndo usar√≠as precision vs recall?
    Un ejemplo de autenticaci√≥n multifactor en IoT.
    ¬øQu√© parte del CIA protege un WAF?


Retos por descubrimiento (lo que har√©is en clase)


Semana 1 ¬∑ ‚ÄúDel sensor al lago‚Äù

Reto A ‚Äî Edge & Ingesta (IoT + broker):

Simula un ‚Äútracker‚Äù que env√≠a JSON cada 2 s: {temp, g_force, parcel_id, ts}. Publica por MQTT en sensors/parcel/{id} y consume en Node-RED (o n8n/HTTP) para persistir en PostgreSQL.

Criterios de aceptaci√≥n:

    Reintento si falla el almacenamiento (no perder datos).
    Esquema claro y timestamps en UTC.

Reto B ‚Äî Diagrama de arquitectura (Cloud/Big Data):

Dibuja un bloque C4/arquitectura con Edge ‚Üí Broker ‚Üí Ingest ‚Üí Storage ‚Üí Dashboard. Se√±ala rasgos NIST que justifican tus decisiones (elasticidad, multi-tenancy).


Semana 2 ¬∑ ‚ÄúDe dato a decisi√≥n con seguridad‚Äù

Reto C ‚Äî Detecci√≥n/ML simple:

Implementa regla o modelo ligero: alerta si temp>8¬∞C o g_force>2.5 durante > N eventos. (Opcional ML: logistic entrenada con datos de prueba).

Criterios: F1 ‚â• 0.7 sobre un set etiquetado propio de 200 eventos.

Reto D ‚Äî Panel & Alertas:

Crea 3 KPIs en Metabase:

    % env√≠os en SLA (sin alerta), 2) Tiempo medio hasta alerta, 3) % falsos positivos.
    Y 1 alerta (email/log) con throttling (no spam).

Reto E ‚Äî Seguridad por dise√±o (CIA):

Entrega mini-amenazas y mitigaciones (1 l√≠nea cada una):

    Confidencialidad: credenciales del broker ‚Üí .env / rotaci√≥n.
    Integridad: hashing o checks de carga (longitud, rango).
    Disponibilidad: cola/reintento si DB no responde.
    A√±ade IAM b√°sico (roles: lector/ingesta) y hardening m√≠nimo del broker.

Boss-fight (incidente simulado): el profe ‚Äúcorta‚Äù la DB 60 s. Deb√©is no perder eventos (buffer/retry) y registrarlo en el informe.


Entregables (√∫nico ZIP en Blackboard)

‚îú‚îÄ‚îÄ diagrams/arquitectura_T2.png      (Reto B)
‚îú‚îÄ‚îÄ flows/                            (Node-RED o n8n + README de arranque)
‚îú‚îÄ‚îÄ db/ddl.sql                        (tablas y notas de √≠ndices)
‚îú‚îÄ‚îÄ dashboards/metabase_export.json   (o capturas)
‚îú‚îÄ‚îÄ analytics/labels.csv              (etiquetas para evaluar regla/ML)
‚îú‚îÄ‚îÄ security/CIA_minithreats.md       (amenazas y mitigaciones)
‚îú‚îÄ‚îÄ doc/Informe_T2_EquipoX.pdf        (m√°x. 4 p√°gs., ver √≠ndice)
‚îî‚îÄ‚îÄ video/URL.txt                     (demo 3‚Äì5 min)
 
 

Informe (4 p√°gs.) ‚Äì √≠ndice sugerido

    Arquitectura y decisiones Cloud/IoT (con rasgos NIST y 5V)
    Ingesta y almacenamiento (esquema, retry, latencia).
    Detecci√≥n/ML y KPIs (m√©tricas y resultados).
    Seguridad por dise√±o (CIA/IAM) + boss-fight (qu√© pas√≥ y c√≥mo lo resolvisteis).


5) Calendario (2 semanas)

    D√≠a 1: Kick-off + Retos A/B (en clase).
    D√≠a 4: Checkpoint A/B (10‚Ä≤ por equipo).
    D√≠a 8: Retos C/D/E (en clase).
    D√≠a 12: Checkpoint C/D/E y boss-fight.
    D√≠a 14 (23:59): Entrega final (ZIP + informe + v√≠deo).


6) R√∫brica (10% de la asignatura, 10 puntos)

    Arquitectura & Teor√≠a (2 pts) ‚Äî claridad del diagrama, uso correcto de Cloud/5V/IoT (cita breve al Tema 2).
    Ingesta & Storage (2 pts) ‚Äî flujo robusto (retry, esquema, timestamps).
    Detecci√≥n/ML (2 pts) ‚Äî regla/modelo correcto; evaluaci√≥n con etiquetas propias (F1 o m√©trica justificada).
    KPIs & Alertas (2 pts) ‚Äî 3 KPIs √∫tiles y una alerta con throttling.
    Seguridad (1.5 pts) ‚Äî CIA/IAM razonados y boss-fight superada (sin p√©rdida).
    Comunicaci√≥n (0.5 pts) ‚Äî informe (‚â§4 p√°gs.) + demo clara (3‚Äì5‚Ä≤).

Penalizaciones: credenciales en repo (‚àí1), demo no reproducible (‚àí2), diagrama ilegible (‚àí0.5).


7) C√≥mo empezar (gu√≠a r√°pida para el alumnado)

    Lee Cloud, IoT y Big Data del Tema 2 .
    Arranca broker (Mosquitto o Node-RED) y Postgres (Docker).
    Publica datos sint√©ticos (script o inject) y persiste en DB.
    Crea 3 KPIs en Metabase y valida con un lote etiquetado.
    Dise√±a mitigaciones CIA m√≠nimas y prueba la boss-fight.


Mini-gu√≠a de enganche (para ambos casos)

    Personas reales: poned nombre y ‚Äúdolor‚Äù a los stakeholders (Luc√≠a/√ìscar).
    Tablero de progreso: marcad cap√≠tulos completados y riesgos (verde/√°mbar/rojo).
    Decisiones visibles: cada PR o cambio en el flujo debe adjuntar qu√© KPI impacta.
    Demo primero: al iniciar cada sesi√≥n, 2‚Ä≤ de demo de lo conseguido (aunque sea peque√±o).


8) Regla de oro (flip real)

    Flipped classroom: llegas a clase con lo b√°sico le√≠do; el tiempo pr√°ctico es para descubrir y resolver.
    Los cap√≠tulos traen ‚ÄúPrueba superada cuando‚Ä¶‚Äù con criterios medibles.
    La defensa final debe conectar arquitectura ‚Üî m√©tricas ‚Üî seguridad.
